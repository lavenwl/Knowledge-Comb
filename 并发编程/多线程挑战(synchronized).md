参考文档: [笔记-20190511-多线程的基本原理及挑战.pdf](source/笔记-20190511-多线程的基本原理及挑战.pdf) 

### Synchronized

> synchronized是重量级锁, JavaSE 1.6 对其进行了各种优化.引入了偏向锁, 与轻量级锁.

#### 基本语法

synchronized有三种方式来加锁:

* 修饰实例方法: 作用域当前实例, 获取当前实例的锁 `实例锁`
* 静态方法: 作用域当前类对象 `类锁`
* 修饰代码块: 需要制定锁对象

### 锁的存储

* 在Hotspot虚拟机中, 对象在内存中的布局可以分为三个区域:
    * 对象头(Header)
    * 实例数据(Instance Data)
    * 对齐填充(Padding)
* 使用new 创建一个对象实例时候, JVM(Hotspot)层面实际上会创建一个instanceOopDesc对象
* instanceOopDesc对象继承自oopDesc
* oopDesc的定义包含两个成员, _mark, _metadata
* _mark 表示对象标记, 属于markOop类型, 也就是MarkWorld, 它记录了对象和锁的相关信息

| 锁状态   | 23bit  | 2bit     | 4bit       | 是否偏向锁(1bit) | 锁标志位 |
| -------- | ------ | -------- | ---------- | ---------------- | -------- |
| 无锁     | 对象的 | HashCode | 分代年龄   | 0                | 01       |
| 偏向锁   | 线程ID | Epoch    | 分代年龄   | 1                | 01       |
| 轻量级锁 | 指向   | 栈中锁   | 记录的指针 |                  | 00       |
| 重量级锁 | 指向   | 重量级   | 锁指针     |                  | 10       |
| GC标记   | 空     |          |            |                  | 11       |



### Synchronized锁升级

在JDK 1.6之前, synchronized还是重量级锁, 虽然保证了线程的安全, 但是也带来了性能的开销, 真正的程序出现多线程抢占的情况又不是一直发生, 所以在JDK 1.6 之后对synchronized锁进行了优化, 提供了synchronized锁升级的机制.在synchronized中的锁存在四种状态: `无锁`, `偏向锁`, `轻量级锁`, `重量级锁`.

### 偏向锁的基本原理

鉴于大部分情况下, 共享资源多是由同一个线程重复获得,  所以.当一个线程访问加了同步锁的代码块时, 会在对象头中存储当前线程的ID, 后续这个线程进入和退出这段加了同步锁的代码块时, 不需要再次加锁与释放锁, 而是直接比较对象头里面是否存储了指向当前线程的偏向锁. **如果相等, 表示偏向锁偏向于当前线程, 不需要重复获取锁**.





















































