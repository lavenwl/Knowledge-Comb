### 多个线程顺序打印的问题

* synchronized, wait, notify

    ```java
    public class SynchronizedPrinterThread implements Runnable {
    
        private SynchronizedPrinterThread prePrinter;
    
        int count = 10;
    
        @Override
        public void run() {
            synchronized (prePrinter) {
                while(count > 0) {
                    synchronized (this) {
                        System.out.println(Thread.currentThread().getName());
                        count--;
                        this.notifyAll();
                    }
                    try {
                        if (count == 0) {
                            prePrinter.notifyAll();
                        } else {
                            prePrinter.wait();
                        }
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        }
    
        public void setPrePrinter(SynchronizedPrinterThread runnable) {
            this.prePrinter = runnable;
        }
    
        public static void main(String[] args) throws InterruptedException {
            SynchronizedPrinterThread threadA = new SynchronizedPrinterThread();
            SynchronizedPrinterThread threadB = new SynchronizedPrinterThread();
            SynchronizedPrinterThread threadC = new SynchronizedPrinterThread();
    
            threadA.setPrePrinter(threadC);
            threadB.setPrePrinter(threadA);
            threadC.setPrePrinter(threadB);
    
            new Thread(threadA, "A").start();
            Thread.sleep(10);
            new Thread(threadB, "B").start();
            Thread.sleep(10);
            new Thread(threadC, "C").start();
        }
    }
    ```

* Lock, state

    ```java
    import java.util.concurrent.locks.Lock;
    import java.util.concurrent.locks.ReentrantLock;
    
    public class LockStatePrintThread implements Runnable {
    
        private int i;
        private Lock lock;
        private State state;
        private String name;
    
        private int count = 10;
        @Override
        public void run() {
            while(count > 0) {
                lock.lock();
                if (state.state % 3 == i) {
                    System.out.println(name);
                    count--;
                    state.state++;
                }
                lock.unlock();
            }
        }
    
        public LockStatePrintThread(int i, Lock lock, State state, String name) {
            this.i = i;
            this.lock = lock;
            this.state = state;
            this.name = name;
        }
    
        private static class State {
            protected int state = 0;
        }
    
        public static void main(String[] args) throws InterruptedException {
            Lock lock = new ReentrantLock();
            State state = new State();
    
            LockStatePrintThread threadA = new LockStatePrintThread(0, lock, state, "A");
            LockStatePrintThread threadB = new LockStatePrintThread(1, lock, state, "B");
            LockStatePrintThread threadC = new LockStatePrintThread(2, lock, state, "C");
    
            new Thread(threadA).start();
            new Thread(threadB).start();
            new Thread(threadC).start();
        }
    }
    ```

* Lock, Condition

    ```java
    import java.util.concurrent.locks.Condition;
    import java.util.concurrent.locks.Lock;
    import java.util.concurrent.locks.ReentrantLock;
    
    public class ConditionPrinterThread implements Runnable {
    
        private Lock lock;
    
        private Condition prePrinterCondition;
    
        private Condition currPrinterCondition;
    
        int count = 10;
    
        @Override
        public void run() {
            try {
                lock.lock();
                while(count > 0) {
                    System.out.println(Thread.currentThread().getName());
                    count--;
                    currPrinterCondition.signal();
                    if (count == 0) {
                        prePrinterCondition.signalAll();
                    } else {
                        prePrinterCondition.await();
                    }
                }
            } catch (Exception e) {
                e.printStackTrace();
            } finally {
                lock.unlock();
            }
        }
    
        public ConditionPrinterThread(Lock lock, Condition currPrinterCondition, Condition prePrinterCondition) {
            this.lock = lock;
            this.currPrinterCondition = currPrinterCondition;
            this.prePrinterCondition = prePrinterCondition;
        }
    
        public static void main(String[] args) throws InterruptedException {
    
            Lock lock = new ReentrantLock();
    
            Condition conditionA = lock.newCondition();
            Condition conditionB = lock.newCondition();
            Condition conditionC = lock.newCondition();
    
            ConditionPrinterThread threadA = new ConditionPrinterThread(lock, conditionA, conditionC);
            ConditionPrinterThread threadB = new ConditionPrinterThread(lock, conditionB, conditionA);
            ConditionPrinterThread threadC = new ConditionPrinterThread(lock, conditionC, conditionB);
    
            new Thread(threadA, "A").start();
            new Thread(threadB, "B").start();
            new Thread(threadC, "C").start();
        }
    }
    ```

* semaphore

    ```java
    import java.util.concurrent.Semaphore;
    
    public class SemaphorePrinterThread implements Runnable {
    
        private int count = 10;
    
        private Semaphore currentSemaphore;
    
        private Semaphore nextSemaphore;
    
        public SemaphorePrinterThread(Semaphore currentSemaphore, Semaphore nextSemaphore) {
            this.currentSemaphore = currentSemaphore;
            this.nextSemaphore = nextSemaphore;
        }
    
        @Override
        public void run() {
            while(count > 0) {
                try {
                    currentSemaphore.acquire();
                    count--;
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread().getName());
                nextSemaphore.release();
            }
        }
    
        public static void main(String[] args) {
            Semaphore semaphoreA = new Semaphore(1);
            Semaphore semaphoreB = new Semaphore(0);
            Semaphore semaphoreC = new Semaphore(0);
    
            new Thread(new SemaphorePrinterThread(semaphoreA, semaphoreB), "A").start();
            new Thread(new SemaphorePrinterThread(semaphoreB, semaphoreC), "B").start();
            new Thread(new SemaphorePrinterThread(semaphoreC, semaphoreA), "C").start();
        }
    }
    ```

* AtomicInteger

    ```java
    import java.util.concurrent.atomic.AtomicInteger;
    
    public class AtomicIntegerPrinterThread implements Runnable {
    
        AtomicBox atomicBox;
    
        int i;
    
        public AtomicIntegerPrinterThread(AtomicBox atomicBox, int i) {
            this.atomicBox = atomicBox;
            this.i = i;
        }
    
        @Override
        public void run() {
            while(atomicBox.atomicInteger.get() < atomicBox.MAXVALUE) {
                if (atomicBox.atomicInteger.get() % 3 == i) {
                    System.out.println(Thread.currentThread().getName());
                    atomicBox.atomicInteger.getAndIncrement();
                }
            }
        }
    
        private static class AtomicBox{
            AtomicInteger atomicInteger = new AtomicInteger(0);
            protected static final int MAXVALUE = 30;
        }
    
        public static void main(String[] args) {
            AtomicBox atomicBox = new AtomicBox();
            new Thread(new AtomicIntegerPrinterThread(atomicBox, 0), "A").start();
            new Thread(new AtomicIntegerPrinterThread(atomicBox, 1), "B").start();
            new Thread(new AtomicIntegerPrinterThread(atomicBox, 2), "C").start();
        }
    }
    ```

    