### Volatile的作用

volatile可以使得在多处理器环境下保证了共享变量的可见性.

### 什么叫缓存一致性

有了高速缓存的存在, 在多核状态下, 每一个核心有自己独有的一块高速缓存, 操作状态保存在各自的缓存中, 从而导致不同的核心获取到的结果不一致的问题.

### 解决缓存一致性问题

* 总线锁:在多核cpu下, 当其中一个处理器要对共享内存进行操作的时候, 在总线上发出一个lock信号, 这个信号是的其他处理器无法通过总线来访问到共享内存中的数据. 这种锁的开销比较大.
* 缓存锁: 核心机制是基于缓存一致性协议来实现的:
    * 缓存一致性协议: 为了达到数据访问的一致. 需要各个处理器缓存时遵循一些协议, 在读取时根据协议来操作, 常见的协议有`MSI`, **`MESI`**, `MOSI`等.下面简单介绍mesi
        * M(Modify)表示共享数据只缓存在当前cpu缓存中,并且是被修改的状态, 也就是缓存的数据和主内存中的数据不一致.
        * E(Exlusive)表示缓存的独占状态, 数据只缓存在当前cpu缓存中, 且数据没有被修改.
        * S(Shared)表示数据可能被多个cpu缓存, 且各个缓存中的数据不一致
        * I(Invalid)表示缓存已经失效.
    * 在MESI协议中, 每个缓存的缓存控制器不仅知道自己的读写操作, 而且也监听其他的缓存的读写操作.
    * MESI协议下CPU的读写遵循以下原则
        * cpu读请求: 缓存处于M, E, S状态都可以被读取, I状态CPU只能从主存中读取数据.
        * cpu写请求: 缓存处于M, E状态才可以被写, 对于S状态的写, 需要将其他CPU中的缓存行置位无效才可写.
* 基于MESI的缓存锁在同步数据状态时会存在阻塞cpu的情况, 为了优化cpu的使用率, 引入storebuffer, 是个核心将需要invalid的数据写入storebuffer中, 继续执行后续的指令, 从而提高cpu的使用效率. **但是**:由于存在异步操作, 从而导致了`指令重排序`的问题.
* cpu层面提供了memory barrier(内存屏障)的指令, 从硬件层面来看这个内存屏障就是cpu flush storebuffer中的指令. 软件层面可以决定在合适的地方来插入内存屏障.
    * x86的memory barrier 指令包括lfence(读屏障), sfence(写屏障)mfence(全屏障)
        * Store Memory Barrier(写屏障) 告诉处理器在写屏障之前的所有已经存储在存储缓存(store bufferes)中的数据同步到主内存, 简单来说就是在写屏障前的指令的结果对屏障之后的读或者写是可见的
        * Load Memory Barrier(读屏障)
        * Full Memory Barrier(全屏障)

### 什么是JMM











































参考文档: [【笔记】线程安全性的原理分析.pdf](source/[笔记]线程安全性的原理分析.pdf)  [一个问题引发的思考.pdf](source/一个问题引发的思考.pdf) 













































