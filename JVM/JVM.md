### 虚拟机的类加载机制

1. 装载(Load)

   * 通过一个类的全限定名获取定义此类的二进制字节流
   * 将这个细节流所代表的静态存储结构转化为方法区中运行时数据结构
   * 在java堆中生成一个代表这个类的java.lang.Class对象, 作为对方法区中这些数据的访问入口

2. 链接(Link)

   1. 验证(Verify)

      文件格式, 元数据,字节码,引用符号的验证

   2. 准备(Prepare)

      为类的静态变量分配内存, 并将其初始化为默认值

   3. 解析(Resolve)

      把类中的符号引用转换为直接引用

3. 初始化(Initialize)

   对类的静态变量, 静态代码块执行初始化操作

### 什么是类加载器

在装载的第一步中, 需要通过类的全限定名获取其定义的二进制字节流, 这个过程需要借助类加载器来完成, 顾名思义, 就是用来加载Class文件的.

### 类加载器的分类

| 类加载器              | 加载目录                                                     | 说明                                                         |
| --------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| Bootstrap Classloader | $JAVA_HOME/jre/lib/rt.jar                                    | 由C++实现, 不是Classloader子类                               |
| Extension Classloader | $JAVA_HOME/jre/lib/*.jar或-Djava.ext.dirs指定目录下的jar包   | 负责加载java平台中扩展功能的一些jar包                        |
| App Classloader       | classpath中指定的jar包或-Djava.class.path所指定目录下的类和jar包 |                                                              |
| Custom Classloader    | 自定义                                                       | 通过java.lang.ClassLoader的子类自定义加载class,属于应用程序根究自身需要自定义的装载器 |

### 虚拟机类加载原则

* 检查顺序: 检查一个类是否被加载, 顺序是自下向上.
* 加载顺序: 加载一个类的顺序, 顺序是自上向下.

什么是双亲委派机制

如果一个类加载器在接到一个类加载的请求时, 它首先不会自己去加载这个类, 而是先把这个请求任务委托给自己的父类去完成, 一次递归, 如果父类加载可以完成这个类的加载任务, 就成功返回, 如果这个父类加载器无法完成此任务时, 就自己去加载.

> 优点:使java中的对象有了加载的优先级, 可以有效控制重复加载的问题

运行时数据区的划分

1. 方法区(Method Area)

   > 方法区是线程共享的内存区域, 是虚拟机启动时创建的
   >
   > 存储一倍虚拟机加载的类信息, 常量, 静态变量, 及时编译器编译的代码等数据
   >
   > 是堆的逻辑区域, 如果无法满足分配需求, 将抛出OutOfMemoryError
   >
   > JDK1.8中将Metaspace, 之前叫:Perm Space

   > Class文件中除了有类的版本, 字段, 方法, 接口等描述信息外, 还有一项信息就是常量池, 用于存放编译时期生成的各种字面量和符号引用. 这部分内容将在类加载后进入方法区的运行时常量池中存放

2. 堆(Heap)

   > 堆是线程共享的, 在虚拟机启动时创建
   >
   > java对象及数组都是在堆上分配的, 是java虚拟机中所管理内存最大一块

3. 虚拟机栈(Java Virtual Machine Stacks)

   > 用来保存java线程的运行状态的区域
   >
   > 一个方法调用形成一个栈帧,执行完一个方法, 弹出该栈帧

4. 本地方法栈(Native Method Stacks)

   > 如果线程当前执行的是Native类型的, 这些方法会在本地方法栈中执行

5. 程序计数器(The PC Register)

   > 用来记录cpu切换线程时的线程执行状态
   >
   > 如果该线程正在执行java线程, 则用来记录当前虚拟机中字节码指令地址
   >
   > 如果正在执行的是native 方法, 这个计数器为空

### java虚拟机栈的栈帧具体包含哪些内容

1. 局部变量表(Local Variables)

    方法中定义的局本部变量及方法的参数存放在这张表中

    > 局部变量表中的变量不可以直接使用, 如需要使用的话, 必须通过相关指令将其加载至操作数栈中作为操作数使用

2. 操作数栈(Operand Stack)

    以压栈与出栈的方式存储操作数

3. 动态链接(Dynamic Linking)

    每个栈帧中都包含一个指向运行时常量池中该栈帧所属方法的引用, 持有这个引用是为了支持方法调用过程中的动态链接.(A reference to the run-time constant pool)

4. 方法返回地址(Return Address)

    当一个方法开始执行后, 只有两种方式可以退出, 一种是遇到方法返回的字节码指令, 一种是遇见异常, 并且这个异常没有在方法体内得到处理.

### 运行时内存的引用指向

* 栈指向堆: 栈中一个变量, 类型为引用类型, 这时栈中元素指向堆中对象
* 方法区指向堆: 静态变量为引用类型, 指向堆中对象
* 堆指向方法区: 堆中对象指向方法区对应类的具体信息

### Java对象内存布局

* 对象头 **`20Byte`**
    * Mark Word **`8Byte`**
    * Class Pointer (指向对象对应的类元数据的内存地址) **`8Byte`**
    * Length 数组对象特有 **`4Byte`**
* 实例数据: 包含了对象的所有成员变量, 大小由变量类型决定
    * boolean, byte:  **`1Byte`**
    * short, char:  **`2Byte`**
    * int, float:  **`4Byte`**
    * long, double:  **`8Byte`**
    * reference:  **`8Byte`**
* 对齐填充: 保证对象的大小为8字节的整数倍

### 内存模型

> * 堆
>     * Old区
>     * Youny区
>         * Eden区
>         * Survivor区 
>             * S0 (from)
>             * S1 (to)
> * 非堆
>
> Eden:s0:s1=8:1:1

![image-20200817172752357](JVM.assets/image-20200817172752357.png)

### GC的种类

* Minor GC: 新生代
* Major GC: 老年代
* Full GC: 新生代 + 老年代

### 如何确认一个对象是垃圾

* 引用计数法

    就某一个对象而言, 如果应用程序中持有该对象的引用, 就说明该对象不是垃圾, 如果一个对象没有任何指针对齐引用, 就是垃圾.

    > 如果AB相互持有引用, 导致永远无法回收的问题

* 可达性分析

    通过GC Root的对象, 开始向下寻找, 看某个对象是否可达.

    > 能作为GC Root: 类加载器, Thread, 虚拟机栈的本地变量表, static成员, 常量引用, 本地方法栈的变量.

### 垃圾回收算法

* 标记-清除(Mark-Sweep)

    标记处所有需要回收的对象, 清除掉被标记的对象, 释放内存空间

    > 缺点: 
    >
    > * 标记和清除两个过程比较耗时, 效率不高
    > * 会产生大量不连续的内存碎片, 空间碎片太多会导致无法找到连续的内存空间而触发一次GC操作

* 复制(Copying)

    将内存划分为两个相等的区域, 每次只是用一块, 当其中一块内存是用完了, 就将存货的对象复制到另外一块内存上面, 然后把已经是用的内存空间一次清除掉

* 标记-整理(Mark-Compact)

    

































































### [CMS和G1的区别](https://www.cnblogs.com/rgever/p/9534857.html)

