### synchronized和lock区别(蚂蚁金服)

1. synchronized是Java中并发控制的关键字
2. lock则是Java的juc包内的接口

| 类型     | synchronized                                                 | Lock       |
| -------- | ------------------------------------------------------------ | ---------- |
| 存在层次 | Java关键字, 存在JVM层面                                      | 是一个借口 |
| 锁的释放 | 1. 获取锁的线程执行完同步代码块释放锁. 2. 线程执行发生异常, jvm会让线程释放锁 |            |



### synchronized实现(蚂蚁金服)

1. synchronized是Java中并发控制的关键字. 作用于对象上
2. synchronized主要有两种用法, 作用于方法, 同步代码块. 
3. 保证代码的原子性, 可见性和有序性.但不会处理重排序及代码优化的过程
4. synchronized利用对象的MarkWorld区域,以及moniter监控器的moniterEnter以及moniterExit指令以及对应的计数器, 来实现锁以及锁的控制.
5. jdk6之前的实现是直接锁.jdk6以后引入了偏向锁, 轻量级锁, 重量级锁的概念, 中间通过锁膨胀来实现所切换.

### 线程池的实现原理(蚂蚁金服)

线程池维护一个线程集合, 与任务队列. 多个线程同时执行任务队列内的各个任务.

当线程池初始化时, 默认情况下线程池内的线程是没有创建的, 当然, 如果需要创建也可以通过提供的方法来进行一个线程的预创建, 与所有线程的预创建.现在已默认情况继续说明.

当任务提交时: 线程池会有如下步骤进行判断:

1. 如果线程池内的线程数量小于核心线程数, 则新建一个线程进行任务的执行.
2. 如果线程吃内的线程数大于等于核心线程数, 则添加到任务队列
3. 如果线程数大于等于核心线程数且任务队列已满, 则判断当前线程数是否大于最大线程数, 如果小于最大线程数, 则创建新的线程执行任务.
4. 如果当前线程数大于核心线程数, 且队列已满, 且大于最大线程数, 则拒绝任务.

具体的拒绝策略有五种:

* 直接抛出异常, 也是默认策略
* 调用者所在的线程来执行任务
* 丢弃任务队列最前面的任务, 执行当前任务
* 直接丢弃任务
* 重写RejectedExecutionHandler方法, 自定义拒绝策略

###  join的底层实现

join方法内部调用了wait(0)方法, 使得线程阻塞, 当线程执行完毕后, 会执行notifyAll方法, 从而唤醒wait()方法, 继续后续的逻辑.

### volited关键字, 使用多线程模型具体画图解释其原理, 什么是并发的原子性,与可见性

JMM 为实现多线程下的数据一致性问题, 提供了Volited关键字解决此问题.

原子性: 指所有操作一次性执行完毕, 相对于其他线程不可以中断执行.要么不执行, 要么执行完毕

可见性: 一个线程的写操作在后续的读操作中可见.在单核下没有问题,但是多核下运行会出现问题.

### synchronized 关键字是乐观的还是悲观的

悲观锁

### 平常使用什么在多线程环境下控制并发

synchronized, reentrantLock, semaphore, wait, join, sleep, loadbarrier, countDownLatch, BlockingQueue, ReentrantReadWriteLock