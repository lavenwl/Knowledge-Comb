### synchronized和lock区别(蚂蚁金服)

1. synchronized是Java中并发控制的关键字
2. lock则是Java的juc包内的接口

| 类型     | synchronized                                                 | Lock       |
| -------- | ------------------------------------------------------------ | ---------- |
| 存在层次 | Java关键字, 存在JVM层面                                      | 是一个借口 |
| 锁的释放 | 1. 获取锁的线程执行完同步代码块释放锁. 2. 线程执行发生异常, jvm会让线程释放锁 |            |



### synchronized实现(蚂蚁金服)

1. synchronized是Java中并发控制的关键字. 作用于对象上
2. synchronized主要有两种用法, 作用于方法, 同步代码块. 
3. 保证代码的原子性, 可见性和有序性.但不会处理重排序及代码优化的过程
4. synchronized利用对象的MarkWorld区域,以及moniter监控器的moniterEnter以及moniterExit指令以及对应的计数器, 来实现锁以及锁的控制.
5. jdk6之前的实现是直接锁.jdk6以后引入了偏向锁, 轻量级锁, 重量级锁的概念, 中间通过锁膨胀来实现所切换.

### 线程池的实现原理(蚂蚁金服)

线程池维护一个线程集合, 与任务队列. 多个线程同时执行任务队列内的各个任务.

当线程池初始化时, 默认情况下线程池内的线程是没有创建的, 当然, 如果需要创建也可以通过提供的方法来进行一个线程的预创建, 与所有线程的预创建.现在以默认情况继续说明.

当任务提交时: 线程池会有如下步骤进行判断:

1. 如果线程池内的线程数量小于核心线程数, 则新建一个线程进行任务的执行.
2. 如果线程池内的线程数大于等于核心线程数, 则添加到任务队列
3. 如果线程数大于等于核心线程数且任务队列已满, 则判断当前线程数是否大于最大线程数, 如果小于最大线程数, 则创建新的线程执行任务.
4. 如果当前线程数大于核心线程数, 且队列已满, 且大于最大线程数, 则拒绝任务.

具体的拒绝策略有五种:

* 直接抛出异常, 也是默认策略
* 调用者所在的线程来执行任务
* 丢弃任务队列最前面的任务, 执行当前任务
* 直接丢弃任务
* 重写RejectedExecutionHandler方法, 自定义拒绝策略

### 线程池的运行状态

> 运行状态保存在int值的高3位(所有数值左移29`Integer.SIZE - 3`位)

* RUNNING:  `-1 << 29`  接收新任务, 并执行队列中的任务

* SHUTDOWN: `0 << 29` 不接受新任务, 但执行队列中的任务

* STOP: `1 << 29` 不接受新任务, 不执行队列中的任务, 中断正在执行的任务.

* TIDYING: `2 << 29` 所有的任务都已结束, 线程数量为0, 处于该状态的线程池即将调用terminated()方法

* TERMINATED: `3 << 29` 执行完成

### 线程的生命周期

> 一个线程6种状态： new, runnable, blocked, waiting, time\_waiting, terminated

* NEW：初始状态， 线程被构建，但还没调用start方法
* RUNNABLE：运行状态， JAVA线程中表操作系统中的就绪和运行两种状态统称为“运行中“
* BLOCKED：阻塞状态，线程进入等待状态， 放弃CPU使用权
    * 等待阻塞：运行线程执行wait方法，JVM会把当前线程放入到等待队列。
    * 同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁已被其他线程锁占用了， 那么JVM会把当前线程放入到锁池中
    * 其他阻塞：运行的线程执行Thread.sleep或者t.join方法， 或者发出了I/O请求时，JVM会把当前线程设置为阻塞状态， 当sleep结束，join线程终止，io处理完毕则线程恢复
* WAITING：等待状态
* TIME\_WAITING：超时等待状态，超时以后自动返回
* TERMINATED：终止状态， 表示当前线程执行完毕

![image-20200309182528156](多线程高并发.assets/image-20200309182528156.png)

### 

###  join的底层实现

join方法内部调用了wait(0)方法, 使得线程阻塞, 当线程执行完毕后, 会执行notifyAll方法, 从而唤醒wait()方法, 继续后续的逻辑.

### volatile关键字, 使用多线程模型具体画图解释其原理, 什么是并发的原子性,与可见性

JMM 为实现多线程下的数据一致性问题, 提供了Volited关键字解决此问题.

原子性: 指所有操作一次性执行完毕, 相对于其他线程不可以中断执行.要么不执行, 要么执行完毕

可见性: 一个线程的写操作在后续的读操作中可见.在单核下没有问题,但是多核下运行会出现问题.

### 什么是volatile

多线程编程中需要注意可见性, 有序性, 原子性的问题. 通常情况下我们会使用synchronized关键字来解决这些问题, 但是synchronized关键字是比较重量级的操作, 对系统性能要求比较大影响, 我们尽量避免使用synchronized关键字来解决问题, 而volatile关键字就是java中用来解决可见性与有序性问题的方案, 对于原子性, 需要强调一点, volatile关键字只能对单次读写操作保证原子性.但是不能保证i++这种操作的原子性,  因为本质上i++是读写两次操作.

### volatile如何保证有序性

基于Java中的happen-before规则, JMM会对volatile变量限制编译器重排序和指令重排序, 从而实现了有序性

>  happen-before规则的内容:(七条)

> * 同一个线程中的，前面的操作 happen-before 后续的操作。（即单线程内按代码顺序执行。但是，在不影响在单线程环境执行结果的前提下，编译器和处理器可以进行重排序，这是合法的。换句话说，这一是规则无法保证编译重排和指令重排）。
> * 监视器上的解锁操作 happen-before 其后续的加锁操作。（Synchronized 规则）
> * 对volatile变量的写操作 happen-before 后续的读操作。（volatile 规则）
> * 线程的start() 方法 happen-before 该线程所有的后续操作。（线程启动规则）
> * 线程所有的操作 happen-before 其他线程在该线程上调用 join 返回成功后的操作。
> * 如果 a happen-before b，b happen-before c，则a happen-before c（传递性）。
>
> 

### volatile如何保证可见性

线程本身并不是直接与内存数据交互的, 而是通过线程的工作内存来完成响应的操作, 这也是导致线程间数据不可见的本质原因. 如果要实现volatile变量的可见性, 直接从这方面入手即可. 对volatile变量的写操作与普通变量的写操作主要区别有两点:

1. 修改volatile变量时会强制将修改后的值刷新到主内存中
2. 修改volatile变量后会导致其他线程工作内存中对应的变量值失效, 因此, 在读取该变量值时候会需要重新读取主内存中的值.

通过以上两个操作可以解决volatile变量的可见性问题

### synchronized 关键字是乐观的还是悲观的

悲观锁

### 平常使用什么在多线程环境下控制并发

synchronized, reentrantLock, semaphore, wait, join, sleep, loadbarrier, countDownLatch, BlockingQueue, ReentrantReadWriteLock

### 多线程如何通信?

> 这里注意: 当设计到多线程通信问题, 并不是说的发送消息, 传递参数类的通信, 这里的通信更多是一个线程意识到另外一个线程的存在以及执行状态

* 可以使用synchronized关键字进行线程通信, 一个线程执行块内元素, 其他线程无法进入, 
* 可以使用thread.join的方式进行通信, 一个线程为执行完毕, 等待的线程无法执行后续操作
* 可以使用Object的wait(), 与notify() 方法实现线程通信, 
* 当然, JUC为我们提供了很多多线程工具可以实现线程间通信: 如
    * Condition, Lock, BlockingQueue, Callable, Future, FutureTask等.

### AQS

 [AQS.md](../../并发编程/多线程基础/AQS.md) 

