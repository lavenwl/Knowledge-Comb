分布式锁的特点:

* 互斥性：和我们本地锁一样互斥性是最基本，但是分布式锁需要保证在不同节点的不同线程的互斥。
* 可重入性：同一个节点上的同一个线程如果获取了锁之后那么也可以再次获取这个锁。
* 锁超时：和本地锁一样支持锁超时，防止死锁。
* 高效，高可用：加锁和解锁需要高效，同时也需要保证高可用防止分布式锁失效，可以增加降级。
* 支持阻塞和非阻塞：和 ReentrantLock 一样支持 lock 和 trylock 以及 tryLock(long timeOut)。
* 支持公平锁和非公平锁(可选)：公平锁的意思是按照请求加锁的顺序获得锁，非公平锁就相反是无序的。这个一般来说实现的比较少。

参考[网页](https://www.sohu.com/a/258876620_463994)

### 分布式锁的实现

目前了解到的分布式锁有三种实现方式.

##### 基于数据库实现分布式锁

###### 基于数据库表实现

>  新建一张表, 以新建一条数据为获取锁, 删除一条数据为释放锁, 利用主键约束控制锁的排他性.

存在的问题:

1. 这种锁依赖于数据库的可用性, 数据库单点, 一但数据库宕机, 业务系统不可用
2. 这种锁没有失效时间, 一但释放锁失败, 数据库中一直存在次数据, 其他线程无法获取锁
3. 这种锁是非阻塞的, 一但插入失败直接返回.
4. 这种锁是非重入的, 同一个线程在没有释放之前无法再次获取

对应的解决办法:

1. 数据库做主从部署
2. 添加定时任务, 一定时间清除超时的数据
3. 程序通过while循环重复试探锁是否释放
4. 添加标记为, 如果是同一个线程已经插入数据, 则按照获取锁处理

###### 基于数据库排他锁实现

> 利用数据库自带的锁实现分布式锁`for update`, (InnoDB 引擎只有在表中存在唯一索引的时候才会使用行级锁).  通过`connection.commit()`提交事务来释放锁

可以解决 锁释放问题, 阻塞问题, 但是没有解决数据单点与可重入问题

另外还有一个问题: MySQL会对执行的SQL进行优化, 具体执行是否使用了唯一索引由Mysql优化决定, 如: 一些小表不使用索引返到会更快.

##### 基于缓存实现分布式锁

Redis实现 参考[网页](https://www.cnblogs.com/williamjie/p/9395659.html)

##### 基于Zookeeper实现分布式锁

临时有序节点, 及watch机制

###  分布式事务的实现

